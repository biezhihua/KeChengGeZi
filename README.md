
做了那些比较好玩的事情:

这个面试题看似是上机题目,实际上考的是,如何找出f(1),f(2*2),f(3*3),f(4*4)....f(n*n)之间的计算规律.

如果找出了计算规律,实际上计算下一个目标值,只是做简单的大数相加/相乘的操作,其时间复杂度为BigInteger的计算

加法和乘法的时间复杂度O(N).

另外一方面,题目要求在超过10^10值时,要以科学计数法表示,实际上就是将实际的f(n*n)的结果化为x.xxxEn的格式,

其时间复杂度也主要是BigInteger.toString()复杂度加上String.substring()的时间复杂度.

这样分析看来,整道题目的难点就在如何找到规律.


而f(1),f(2*2),f(3*3),f(4*4)....f(n*n)之间的计算规律也不难发现.

例如:
f(4) = 2 个 0 +
       3 个 1
     
f(9) = 5 个 3 +   (等于 2 + 3) 
       8 个 4     (等于 2 + 3 + 3)
     
f(16)= 13个 8 +   (等于 5 + 8)
       21个 9     (等于 5 +8 + 8)

f(25)= 34个 15+   (等于 13+21)
       55个 16    (等于 13+21+21)

f(36)= 89个24 +   (等于 34+55)
       144个25    (等于 34+55+55)
       
       ...
       
例如:
f(3) = 1 个 0 +
       2 个 1
       
f(8) = 3 个 3 + (等于 2+1)
       5 个 4   (等于 2+1+2)

f(15)= 8 个 8 + 等于(3 + 5)
       13个 9   等于(3+5+5)

       ... 
       
       
根据以上分析,发现规律后,计算新的f(n*n) (n代表行数),就可以在之前已计算出的结果之上计算,其复杂度相当低.

例如计算 f(1) 至 f(450*450) 的所有BigInteger值,仅需要200ms - 300ms(根据cpu不同,有关系.)